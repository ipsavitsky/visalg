# Процедуры. Функции

## Концепция подзадачи

Пусть у нас есть какой-то алгоритм, например, инструкция по сбору офисного работника на работу:

---

1. Проснуться;
1. Выключить будильник;
1. Подняться с кровати;
1. Пойти в туалет;
1. Почистить зубы;
1. Пойти в кухню;
1. Приготовить завтрак;
... и так далее...

---

Заметим, что его утро красиво разбивается на подзадачи примерно так:

---

1. Встать с кровати
    1. Проснуться;
    1. Выключить будильник;
    1. Подняться с кровати;
1. Привести себя в порядок
    1. Пойти в туалет;
    1. Почистить зубы;
1. Позавтракать
    1. Пойти на кухню;
    1. Приготовить завтрак;

---

Теперь у нас нет необходимости описывать *полный* перечень того, что нашему бедному сотруднику надо сделать с утра. Достаточно один раз вне программы описать, что из себя представляет каждая подзадача, и потом просто писать, что день нашего подопытного состоит из

---

1. Встать с кровати;
1. Привести себя в порядок;
1. Позавтракать;

---

Именно такой концепт - выделение отдельных последовательностей действий в подзадачи - и исполняют в себе подзадачи, или *подпрограммы*. В языке Pascal есть два типа подпрограмм - **процедуры** и **функции**. В примере с офисным работником всё это скорее процедуры. Функция же отличется от процедуры тем, что она умеет отчитываться о результатах своего исполнения. Так, например, если бы у офисного работника была копилка, куда он каждый вечер кидал бы монетку, то операция "взять деньги из этой копилки*была бы*функцией*, которая возвращала бы число -- количество денег, которое удалось достать из копилки.

## Процедуры

Процедуры - подзадачи, которые ничего не возвращают, т.е. *не имеют возвращаемого значения*. Пример процедуры - уже знакомый вам `writeln`. Сам по себе он магией не является. При каждом вызове `writeln` запускается *подпрограмма*, выводящая вам в консоль сообщение, которое вы ей передадите в *параметрах*.

Однако процедуры бывают не только встроенными в язык, их может задавать и сам программист, и делается это следующим образом:

```pascal
{пример процедуры, которая принимает в качестве аргументов число num и символ ch и печатает символ ch n раз}
procedure PrintCharNTimes(num: integer; ch: char);   {задание заголовка(сигнатуры) функции}
var                                                  {блок задания переменных}
  i: integer;
begin                                                {блок кода подпрограммы}
  for i := 1 to num do
  begin
    write(ch)
  end;
end;                                                 {конец подпрограммы - дальше выполнение кода как обычно}
begin
  PrintCharNTimes(10, 'f');                          {вызов подпрограммы}
end.
```

Стоит обратить внимание на то, что *у процедур свои блоки `var` и `begin - end;`, которые оформляются*без точки**. Вызов процедуры происходит из главного блока, который отделён от всех остальных характерными `begin - end.` с точкой.

Заметим, что, как говорится, что происходит в ~~Зелёной миле~~ подпрограмме - остается в подпрограмме. В том числе и определённые в ней переменные (в нашем примере -- `i`). Если в коде выше немного поменять основные `begin - end.`, например, вот так

```pascal
begin
  PrintCharNTimes(10, 'f');
  writeln(i);
end.
```

То мы получим следующую ошибку:

```plaintext
Program1.pas(13) : Неизвестное имя 'i'
```

И действительно, переменной `i` нет в контексте основной программы, т.е. она не объявлена в самом внешнем `var`-е, который относится к блоку `begin - end.`

## Функции

Внешне очень похожи на процедуры, за одной очень интересной особенностью. Пусть есть подпрограмма, которая вычисляет третью степень числа. Такая программа выглядит следующим образом:

```pascal
function Cube(a: integer) : integer;
begin
  Cube := a * a * a;
end;
var
  input, c: integer;
begin
  writeln('Введите число');
  readln(input);
  c := Cube(input);
  writeln(c);
end.
```

Обратите внимание: после того, как создана функция, её можно воспринимать как число от параметра (см. строчку 12 в листинге). В частности, можно вставлять её вызов где угодно, где нужно получить число. Например, в конструкции `if`:

```pascal
  if 27 = Cude(input) then
  begin
  {...}
  end;
```

Итак, два основных отличия функций от процедур:

1. в сигнатуре функции в конце стоит тип возвращаемого значения;
1. в каждой функции заводится дополнительная переменная(которую не надо указывать в `var`). Из функции вернется то значение, какое было записано в него на момент конца подпрограммы(`a * a * a`) на нашем случае. Это значение вернулось и записалось в `c`

## Задачи

1. [Тестовые вопросы](/ull-spring/procedures-and-functions/questions)
1. [Гипотенуза](/ull-spring/procedures-and-functions/hypotenuse)
1. [Пирамида](/ull-spring/procedures-and-functions/pyramid)
