# Предисловие

Каждый x86 процессор(такой с большой вероятностью использует устройство, с которого вы это читаете) построен на базе архитектуры CISC (Complete Instruction Set Computer). При каждой компиляции текст вашей программы сначала преобразуется в ассемблер, а потом при помощи специальной программы, которая тоже называется ассемблер, и линкера собирается в исполняемую программу. Т.е. язык ассемблера - это язык *инструкций* самого процессор? и взаимодействует ассемблер не с системой (хотя с системой тоже при помощи штуки под названием системные вызовы), а конкретно с железками. Железки следующие:

1) АЛУ(арифметико-логическое устройство) - железка, которая ответственна за арифметические операции и операции сравнения (для нас это просто оператор "+" в языке Си).
2) Регистровая память(технически, часть АЛУ) - **единственная** память, с которой умеет взаимодействовать АЛУ. Предельно быстрая, но очень сильно ограниченная. В нашей модели в первом приближении  это 5 переменных типа *unsigned long long*: ax, bx, cx, dx. Если их покажется мало и **ОЧЕНЬ** хочется, можно добавить r1, r2, $\dots$, rn, где n какое-то разумное.
3) Оперативная память, на которой процессор автоматически создает системный стек (который вы, кстати, писали!). Для нас - просто сосиска данных размером, скажем, 16000 байт, бишь *malloc (16000)*.

# Задача

Мы пишем нечто, способное *выполняться*, т.е. обрабатывать текстовые файлы с расширением **.asm** (их можно набирать хоть в блокноте) следующего содержания:

### Программа, складывающая два числа

```nasm
; пропустим все технические детали и задание переменных
; выше задаются переменные a, b и c, все размера dword
 
lit5:               ; это метка. Отделяет собой место в коде, на которое можно перепрыгнуть(при помощи оператора jmp)
 mov ax,5       ; заносим в ax константу 5. К такой записи легко привыкнуть, если рассматривать ее как ax = 5
 mov [c],ax     ; то же самое, что и строчкой выше, но в переменную. Заметим, что устройство управления НЕ МОЖЕТ записать литерал 5 сразу в память, только через регистр. Тут так заведено.
; c = 5
 
addb:            ; раздел, который показывает как сложить два числа 
 mov ax,[a]    ; загружаем a в ax
 mov bx,[b]
 add ax,bx    ; добавляем к значению в ax b, с учетом того, что раньше там была записана a, теперь там a + b, аналогично УУ, АЛУ не может работать с двумя аргументами в памяти, лучше если оба будут в регистрах, или если хотя бы один
 mov [c],ax   ; записываем результат в c
; c = a + b
 
; операции sub и imul(integer multiplication) работают похожим образом, 
; idiv работает по-другому(см. документацию)
```

### Программа с условным оператором

```nasm
; пример ветвления при помощи cmp
cmp_exmpl:
 mov ax, 5      ; ax = 5
 mov bx, 8      ; bx = 8
 cmp ax, bx     ; операция СРАВНЕНИЯ выставляет специальный регистр, который указывает больше или меньше первый аргумент второго
 ja true_mark   ; проверяет флаги, и ЕСЛИ ОНИ ПОДХОДЯТ ПОД УСЛОВИЯ(для ja это то что первый аргумент больше второго) 
 jmp false_mark ; во всех остальных случаях условие не выполняется и надо перейти по false
  
true_mark:
 ; код, который надо выполнить, если 5 > 8
  
false_mark:
 ; код, который надо выполнить, если 5 <= 8
```

### Программма со стеком

```nasm
stack_example: 
 mov ax, 15   ; ax = 15
 push ax    ; запушили ax
 push 10      ; запушили 10 литералом, стек сейчас это 15, 10
 pop bx       ; снимаем верхнее значение со стека, bx = 10
```

[Пример взят отсюда](https://www.csee.umbc.edu/portal/help/nasm/sample.shtml)
[**Удобный читшит для всего**](https://www.cs.uaf.edu/2005/fall/cs301/support/x86/nasm.html)

# Как писать

Вам требуется реализовать в своем ассемблере модельное подмножество x86 ассемблера, содержащее команды:

1) `push`, `pop`, `push_reg`, `pop_reg`

- `push`
  Берёт в себя литерал a.k.a. чиселку *или* название регистра и кидает переданное на предварительно заботливо выделенный вашим процессором стек.
  - `pop`
    Берёт в себя название регистра и отправляет в него текущее значение со стека (об обработке ошибок в этом месте не думать, считаем, что на стеке гаранитрованно что-то есть. Если нет, то проблемы пользователя).

2) `mov`
 Берёт в себя два аргумента: либо два регистра, лиюо регистр и число, либо регистр и область оперативки через *[* *]* (см. пример 1 и 2). Помещает из второго аргумента в первый.
3) `add`, `sub`, `mult`, `div`
 Производит математические операции. У нас эти операции берут один аргумент и и складывают его с `ax`, записывая конечный результат в `ax` же. Тут работа **только** с регистрами, никакой памяти
4) `cmp`, `ja`, `jb`, `je`, `jne`

- `cmp`
  На самом деле, принимает два аргумента, считает их разность и записывает знак(или то что получился 0) в регистр `cx`(или завести специальный регистр `cf`, если хочется)
  - остальное принимает в себя имя метки
   Исходя из значения `cx` (или `cf`) перевести контроль исполнения на метку в программе.
