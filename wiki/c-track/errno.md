# Что такое errno и с чем это едят

В языке Си нет никакой нативной обработки ошибок, а значит приходится пользоваться всякими костылями чтобы эту обработку ошибок сделать. Например, в задании на квадратные уравнения вы пользовались чем-то, похожим на это:

```c
typedef enum {
    quadratic_two_roots, // enum first value
    quadratic_one_root, // enum second value
    quadratic_no_roots, // enum third value
    linear_one_root, // enum fourth value
    linear_no_roots, // enum fifth value
    linear_infinity_roots // enum sixth value
} solution_options;
solution_options calculation_linear(double b, double c, double *x);
```

(спасибо @Wiandop за показательный код)
  Оказывается, этот подход очень распространен в библиотечном коде проекта GNU(читай: во всем что мы прогаем). Например, если мы посмотрим на документацию функции `fopen(...)`(что, я напоминаю, если вы под маком или линуксом происходит командой `man fopen`, а из-под винды можно посмотреть [тут](http://man.he.net/) в поиске), в разделе о возвращаемом значении написано:

```plaintext
RETURN VALUE
       Upon successful completion fopen(), fdopen() and freopen() return a FILE pointer.  Otherwise, NULL is  re‐
       turned and errno is set to indicate the error.
```

Т.е. функция `fopen()` вернет:

- Указатель типа `FILE*`, если программа отработала верно
- `NULL`, если во время выполнения возникла ошибка(например, файл который мы пытаемся открыть, не существует)

 А это значит, что обработка ошибок функции fopen должна происходить примерно вот так:

 ```c
#include <stdio.h>
int main(){
    FILE* file = fopen("blabla.txt", "r");
    if(file == NULL){
        puts("something went wrong with fopen()!");
        return -1;
    }
    //продолжение кода в случае успешного открытия файла
}
```

  Файл `blabla.txt` я специально не создал, а значит моя программа ожидаемо закончится с сообщением `something went wrong with fopen()!`. Но бывают(почти всегда) ситуации, в которых об ошибке хочется знать чуть больше, чем просто то что она произошла. Тут и вступает в дело переменная `errno`, которая глобальная и определена во всех больших хедерах(в том числе в `stdlib.h` и `stdio.h`, но не в `string.h` - подумайте, почему). Где-то в недрах `errno.h` есть специальный _массив строк_ под названием `sys_errlist`, к которому у вас, строго говоря, нет доступа. Строки в этом массиве - сообщения об ошибках, а `errno`, которая выставилась в результате ошибки - индекс в этом массиве, который указывает на описание ошибки которая возникла. Доступа у вас к этому массиву нет, ибо он системный, но есть специальные функции, которые помогают вам выводить ошибки, например `perror()`. Перепишем наш код с обработкой ошибок через `perror()`

```c
#include <stdio.h>
#include <errno.h>
int main(){
    FILE* file = fopen("blabla.txt", "r");
    if(file == NULL){
        perror("main");
        return errno;
    }
    // продолжение кода в случае успешного открытия файла
}
```

  Теперь при ошибке при открытии файла вызовется функция `perror()`, она проверит чему равна переменная `errno`(которая, повторюсь, глобальная и хитро определена в заголовке как `stdio.h`, так и `errno.h`), и она найдет нужное сообщение об ошибке, то есть `main: No such file or directory`. В данном случае я посчитал что ошибка критическая, поскольку любое ее продолжение приведет к Segmentation fault, поэтому после вывода сообщения об ошибке программа завершается с кодом errno(что, вообще говоря, необязательно). Узнать что делает аргумент функции `perror()` остается заданием для читателя. Узнать это можно в уже любимых нами man-страницах ;)
  
  Более лаконично этот код записывается так:

```c
#include <errno.h>
#include <stdio.h>
int main() {
    FILE* file = NULL;
    if ((file = fopen("blabla.txt", "r")) == NULL) {
        perror("main()");
        return errno;
    }
    // продолжение кода в случае успешного открытия файла
}
```

а ЕЩЕ более лаконично(но пользоваться этим решением можно будет только когда и если вы узнаете что такое макросы)

```c
#include <errno.h>
#include <stdio.h>
#define SAFE(call)        \
    if ((call) == NULL) { \
        perror(__func__); \
        return errno;     \
    }
int main() {
    FILE* file = NULL;
    SAFE(file = fopen("blabla.txt", "r"))
}
```

(Это решение плохо тем, что иногда в случае ошибки функции возвращают `NULL`, а иногда `-1` в случае ошибок, такие штуки ВСЕГДА надо проверять в man-страницах)

Важные замечания:

- НЕ стоит проверять значение `errno` в случае успешного выполнения функции, потому что оно, строго говоря, не определено в этом случае(хотя, в большинстве случаев оно будет значения `Success`)
- Если у вас несколько функций подряд, которые используют errno, то проверять наличие ошибки нужно после КАЖДОЙ из них. Например,

```c
#include <stdio.h>
#include <errno.h>
int main(){
    FILE* file1 = fopen("blabla.txt", "r");
    int err = fseek(file1, 0, SEEK_END);
    err = f(file1);
    if(err == -1){
        perror("main");
        return errno;
    }
    // продолжение кода в случае успешного открытия файла
}
```

Если произойдет ошибка в `fseek` - она никогда не поймается

Есть ли альтернативы? Ну, пока не придумали. Даже язык Go, по идеологии внук языка Cи, страдает от постоянных

```go
func main() {
    f, err := os.OpenFile("notes.txt", os.O_RD|os.O_CREATE, 0755)
    if err != nil {
        log.Fatal(err)
    }
}
```

а этот язык сейчас один из самых популярных!(Хотя в Go2 придумали безумно интересный механизм обработки ошибок, кардинально отличающийся от того, что написано здесь и других прочих объектно-ориентированных exception-handling)

Берегите себя и пишите безопасный код ;)
