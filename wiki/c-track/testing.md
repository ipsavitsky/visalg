# Как тестировать свой код

## Ставим проблему

Неясно как писать хорошие тесты, которые бы хорошо проверяли то, как работают ваши функции.

## Решение

1. К коду тестов должны применяться все те же правила, что и к обычному коду. Никаких утечек! Проверяйте все при помощи `valgrind` если вы пользуетесь маком или линуксом, а если на винде, то можете пользоваться запатентованным методом пристального взгляда, или [вот этим](https://github.com/dynamorio/drmemory)(но мы с Димой этим никогда не пользовались, так что придется разбираться самому)
2. ПРИ УСПЕШНОМ ВЫПОЛНЕНИИ ФУНКЦИИ НЕ ЗАБЫВАЙТЕ ПРОВЕРЯТЬ ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ ФУНКЦИИ
3. Анализ покрытия кода тестами

## Анализ покрытия кода тестами

Пусть у нас есть простая наивная реализация вычисления максимума числа

```c
enum retCodes {
    OK,
    NullPointerPassed
};

enum retCodes max(int a, int b, int *res) {
    if(res == NULL){
        return NullPointerPassed;
    }
    if(a > b){
        *res = a;
    } else{
        *res = b;
    }
    return OK;
}
```

Покрытие кода - буквально сколько раз выполнилась каждая строка нашего кода. Мы пытаемся написать такие тесты, чтобы каждая строчка выполнилась хотя бы один раз. Такого покрытия достаточно легко достичь. Поэтому есть еще вторая метрика - покрытие по "ветвям". Каждый раз когда в вашей программе появляется ветвление, будь то `if-statement` или `case-clause` или, например, хитрое вычисление выражение при помощи ленивой логики, в вашей программе появляется ветвление, и ваше тесты, как минимум, должны покрывать каждую возможную ветку в вашей программе(то есть в случае `if-else` проходится по ветви как `if`, так и `else`), а как максимум, каждую комбинацию прохода по ветвям которую можно получить в вашей функции.

Таким образом тест на функцию выше будет выглядеть следующим образом:

```c
enum testRes {
    ok,
    failure
};

enum testRes test_max() {
    int rs;
    //покрываем сначала все возможные ошибки(которых у меня в коде одна)
    if(max(2, 3, NULL) != NullPointerPassed){
        return failure;
    }
    
    //покрываем сначала ветку выполнения условия в нашем if
    if(max(1000, -1000, &rs) != OK){
        return failure;
    }
    //проверяем результат
    if(rs != 1000){
        return failure;
    }
    //проверяем ветку НЕВЫПОЛНЕНИЯ условия в if
    if(max(-3, 17, &rs) != OK){
        return failure;
    }
    //см. выше
    if(rs != 17){
        return failure;
    }
      // все ветки и строки уже были протестированы, но семантически этот тест тут нужен
    if(max(5, 5, &rs) != OK){
        return failure;
    }
    //см. выше
    if(rs != 5){
        return failure;
    }
    return ok;
}
```

Кстати, тут могут помочь макросы(но вам пока таким пользоваться нельзя, но вы можете вернуться сюда потом)

```c
#define SOFT_ASSERT(call) \
    if (!(call)) {        \
        return failure;   \
    }

enum testRes { ok, failure };

enum testRes test_max() {
    int rs;
    SOFT_ASSERT(max(2, 3, NULL) == NullPointerPassed)
    SOFT_ASSERT(max(1000, -1000, &rs) == OK)
    SOFT_ASSERT(rs == 1000)
    SOFT_ASSERT(max(-3, 17, &rs) == OK)
    SOFT_ASSERT(rs == 17)
    SOFT_ASSERT(max(5, 5, &rs) == OK)
    SOFT_ASSERT(rs == 5)
    return ok;
}
```

## Практическая секция

Существуют специальные утилиты, созданные для анализа покрытия кода, и они даже встроены в gcc(а значит они работают на windows!)! Вот небольшой пример использования пайплайна проверки покрытия кода

У меня следующая структура проекта:

```plaintext
.
├── max.c
├── max.h
└── tests.c

0 directories, 3 files
```

Тогда компиляция с треком покрытия кода производится вот так:

```bash
gcc -c --coverage max.c
gcc -c --coverage tests.c
```

После нее появятся специальные служебные файлы с треком покрытия(`*.gcno`)

```plaintext
.
├── max.c
├── max.gcno
├── max.h
├── max.o
├── tests.c
├── tests.gcno
└── tests.o
```

Линковщику тоже надо указать подлинковать библиотеку `--coverage`

```bash
gcc --coverage max.o tests.o
```

Теперь у нас есть экзекьютабл, который мы можем запустить, и он посчитает нам количество выполнений каждой строчки

```bash
./a.out
```

У нас создадутся еще дополнительные файлы `.gcda`

```plaintext
.
├── a.out
├── max.c
├── max.gcda
├── max.gcno
├── max.h
├── max.o
├── tests.c
├── tests.gcda
├── tests.gcno
└── tests.o

0 directories, 10 files
```

Из которых при помощи утилиты `gcov` мы можем сгенерировать отчет о покрытии кода

```bash
gcov max.c -m -b

File 'max.c'
Lines executed:100.00% of 7
Branches executed:100.00% of 4
Taken at least once:100.00% of 4
No calls
Creating 'max.c.gcov'
```

У нас создался файл `max.c.gcov`, который можно открыть и проанализировать. У меня он выглядит как-то так

```plaintext
        -:    0:Source:max.c
        -:    0:Graph:max.gcno
        -:    0:Data:max.gcda
        -:    0:Runs:1
        -:    1:#include "max.h"
        -:    2:
function max called 4 returned 100% blocks executed 100%
        4:    3:enum retCodes max(int a, int b, int *res) {
        4:    4:    if(res == NULL){
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1:    5:        return NullPointerPassed;
        -:    6:    }
        3:    7:    if(a > b){
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:    8:        *res = a;
        -:    9:    } else{
        2:   10:        *res = b;
        -:   11:    }
        3:   12:    return OK;
        -:   13:}
```

Где указано, сколько процентов тестов вызывается какая `branch`, и сколько раз зв все тесты была выполнена какая строчка. Например, строчка

```plaintext
        3:    7:    if(a > b){
```

выполнилась 3 раза, а if

```plaintext
        3:    7:    if(a > b){
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
```

33% вызовов падала в `if`, а 67% - в `else`. Главное, что не 0%

Берегите себя и пишите безопасный код)
